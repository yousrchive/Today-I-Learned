### 연간 평가점수에 해당하는 평가 등급 및 성과금 조회하기

오답풀이
```sql
-- 사원별 성과금 정보 조회

SELECT b.EMP_NO, b.EMP_NAME, b.BONUS * b.SAL , CASE
WHEN SCORE >= 96 THEN 'S'
WHEN SCORE >= 90 THEN 'A'
WHEN SCORE >= 80 THEN 'B'
ELSE 'C'
END AS GRADE
FROM (
SELECT e.EMP_NAME, g.EMP_NO, g.SCORE, e.SAL, CASE 
WHEN SCORE >= 96 THEN 0.2
WHEN SCORE >= 90 THEN 0.15
WHEN SCORE >= 80 THEN 0.10
ELSE 0
END AS BONUS
FROM HR_GRADE g
INNER JOIN HR_EMPLOYEES e ON g.EMP_NO = e.EMP_NO 
) b
ORDER BY EMP_NO ASC;
```

두번째 오답

```sql
-- 사원별 성과금 정보 조회

SELECT b.EMP_NO, b.EMP_NAME, b.GRADE, b.BONUS_PORTION * b.SAL AS BONUS
FROM (
SELECT e.EMP_NAME, g.EMP_NO, g.SCORE, e.SAL, CASE 
WHEN SCORE < 80 THEN 0
WHEN SCORE < 90 THEN 0.1
WHEN SCORE < 96 THEN 0.15
ELSE 0.2
END AS BONUS_PORTION, CASE
WHEN SCORE < 80 THEN 'C'
WHEN SCORE < 90 THEN 'B'
WHEN SCORE < 96 THEN 'A'
ELSE 'S'
END AS GRADE
FROM HR_GRADE g
JOIN HR_EMPLOYEES e ON g.EMP_NO = e.EMP_NO 
) b
ORDER BY EMP_NO ASC;
```

자꾸 같은 사람이 A, B, B, B 이렇게 여러 등급을 받는 것으로 카운트가 되고 있었다.
좀 어려움을 겪다 지피티 답을 찾았는데, 일단 where 조건을 까먹고 있었다.

```sql
SELECT e.EMP_NO, 
       e.EMP_NAME, 
       CASE 
           WHEN AVG(g.SCORE) >= 96 THEN 'S'
           WHEN AVG(g.SCORE) >= 90 THEN 'A'
           WHEN AVG(g.SCORE) >= 80 THEN 'B'
           ELSE 'C'
       END AS GRADE,
       CASE 
           WHEN AVG(g.SCORE) >= 96 THEN e.SAL * 0.2
           WHEN AVG(g.SCORE) >= 90 THEN e.SAL * 0.15
           WHEN AVG(g.SCORE) >= 80 THEN e.SAL * 0.1
           ELSE 0
       END AS BONUS
FROM HR_EMPLOYEES e
JOIN HR_GRADE g ON e.EMP_NO = g.EMP_NO
WHERE g.YEAR = 2022
GROUP BY e.EMP_NO, e.EMP_NAME, e.SAL
ORDER BY e.EMP_NO ASC;
```
알게 된 것은, THEN e.SAL * 0.2 이렇게 바로 연산하는 함수 자체를 컬럼에 삽입하는 것이 가능하다는 것!
이건 프린트해서 같이 풀어보고 싶음...

### 보호소에서 중성화된 동물

오답노트
```sql
-- 보호소에 들어올 당시 중성화 되지 않았지만 보호소를 나갈 당시에는 중성화된 동물의 아이디와 생물종, 이름 조회 
-- ANIMAL_INS에서는 Intact%로 시작 (LIKE)
-- ANIMAL_OUTS에서는 Spayed% or Neutered%로 시작

SELECT i.ANIMAL_ID, i.ANIMAL_TYPE, o.NAME
FROM ANIMAL_INS i
JOIN ANIMAL_OUTS o ON i.ANIMAL_ID = o.ANIMAL_ID
WHERE i.SEX_UPON_INTAKE LIKE 'Intact%' 
AND o.SEX_UPON_OUTCOME LIKE 'Spayed%' OR 'Neutered%'
ORDER BY i.ANIMAL_ID ASC;
```

```sql
-- 보호소에 들어올 당시 중성화 되지 않았지만 보호소를 나갈 당시에는 중성화된 동물의 아이디와 생물종, 이름 조회 
-- ANIMAL_INS에서는 Intact%로 시작 (LIKE)
-- ANIMAL_OUTS에서는 Spayed% or Neutered%로 시작

SELECT i.ANIMAL_ID, i.ANIMAL_TYPE, o.NAME
FROM ANIMAL_INS i
JOIN ANIMAL_OUTS o ON i.ANIMAL_ID = o.ANIMAL_ID
WHERE i.SEX_UPON_INTAKE LIKE 'Intact%' 
AND (o.SEX_UPON_OUTCOME LIKE 'Spayed%' OR o.SEX_UPON_OUTCOME LIKE 'Neutered%')
ORDER BY i.ANIMAL_ID ASC;
```

이때, AND 조건 이후에는 ( ) 괄호를 꼭 달아 묶어주어야 하며
LIKE ' '에 대해서 칼럼명과 like는 생략될 수 없다.

### 입양 시각 구하기(2)
목적 : 몇 시에 입양이 가장 활발하게 일어나는지 확인
각 시간대별 입양이 몇 건이나 발생했는지 조회할 것
결과는 시간대 별로 정리할 것

존재하는 시간대의 count를 집계하고 불러오는 것은 쉽다.
이때 문제점. 기존 0~23 HOUR이 있다고 했을 때, NULL인 HOUR에 대해서는 어떻게 셀 것인가?

그것에 대한 해답을 오래 고민하였는데, WITH RECURSIVE 재귀함수를 통해서 0부터 23까지의 컬럼을 만들 수 있음을 깨달았다.

WITH RECURSIVE HOUR (HOUR) AS (
    SELECT 0
    UNION ALL
    SELECT HOUR + 1
    FROM HOUR_CTE
    WHERE HOUR < 23
)

