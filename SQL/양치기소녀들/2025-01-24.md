### 대장균의 크기에 따라 분류하기 2

```sql

SELECT 
    ID, 
    CASE 
        WHEN SIZE_PERCENTAGE <= 0.25 THEN 'LOW'
        WHEN SIZE_PERCENTAGE <= 0.5 THEN 'MEDIUM'
        WHEN SIZE_PERCENTAGE <= 0.75 THEN 'HIGH'
        ELSE 'CRITICAL'
    END AS COLONY_NAME
FROM (
    SELECT 
        ID, 
        CUME_DIST() OVER (ORDER BY SIZE_OF_COLONY ASC) AS SIZE_PERCENTAGE
    FROM ECOLI_DATA
) AS RankedData
ORDER BY ID ASC;

```

FROM 절에 SELECT 서브쿼리를 사용할 수 있었다!
WITH문을 사용하고는 했는데 ... 이렇게도 되는군

CUME_DIST() OVER (ORDER BY col1 ASC/DESC) AS col2
CASE WHEN ~ END AS col3

### 대장균의 크기에 따라 분류하기1
이건 퍼센트를 기준으로 하는 것이 아니라, 정량적인 평가가 이루어진 것이었다.

```sql
-- 대장균 개체 크기가 100 이하이면 LOW, 100 초과 1000 이하이면 MEDIUM, 1000 초과이면 HIGH로 분류하여 SIZE로 정의

SELECT ID,
CASE 
WHEN SIZE_OF_COLONY <= 100 THEN 'LOW'
WHEN SIZE_OF_COLONY <= 1000 THEN 'MEDIUM'
ELSE 'HIGH'
END AS SIZE
FROM ECOLI_DATA
ORDER BY ID;
```

### 대장균들의 자식의 수 구하기

```sql
SELECT PARENT_ID, count(DISTINCT(ID))
FROM ECOLI_DATA
WHERE PARENT_ID IS NOT NULL
GROUP BY PARENT_ID
ORDER BY PARENT_ID;
```
를 하면, ID를 센 각각의 parent_id들이 나온다.

```sql
WITH CC AS (
    SELECT PARENT_ID,
    COUNT(DISTINCT ID) AS CHILD_COUNT
    FROM ECOLI_DATA
    WHERE PARENT_ID IS NOT NULL
    GROUP BY PARENT_ID
)

SELECT
e.ID AS ID
COALESCE(c.CHILD_COUNT, 0) AS CHILD_COUNT
FROM ECOLI_DATA e
LEFT JOIN CC c ON e.ID = c.PARENT_ID
ORDER BY e.ID ASC;
```

COALESCE, 0

### 대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기

```sql
WITH ac AS(
    SELECT a.HISTORY_ID, a.CAR_ID, a.START_DATE
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY a
    WHERE a.START_DATE >= '2022-07-01' AND a.START_DATE < '2022-11-01'
    GROUP BY a.CAR_ID
    HAVING COUNT(DISTINCT a.HISTORY_ID) >= 5
    )
    
SELECT 
    CAST(DATE_FORMAT(START_DATE, '%m') AS UNSIGNED) AS month, 
    CAR_ID, 
    COUNT(*) AS RECORDS
FROM ac
GROUP BY month, CAR_ID
HAVING COUNT(HISTORY_ID) is not null
ORDER BY month ASC, CAR_ID DESC;
```

```sql
-- 총 대여 횟수가 5회 이상인 자동차들에 대해서! 이면, WHERE CAR_ID
WITH cc AS (SELECT a.HISTORY_ID, a.CAR_ID, CAST(DATE_FORMAT(START_DATE, '%m') AS UNSIGNED) AS MONTH
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY a
    WHERE a.START_DATE >= '2022-07-01' AND a.START_DATE < '2022-11-01'
    GROUP BY a.CAR_ID
    HAVING COUNT(*) >= 5)
    
SELECT 
    CAST(DATE_FORMAT(START_DATE, '%m') AS UNSIGNED) AS MONTH, 
    CAR_ID, 
    COUNT(*) AS RECORDS
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY a
WHERE a.CAR_ID IN (SELECT c.CAR_ID 
               FROM cc c)
GROUP BY month, CAR_ID
HAVING COUNT(HISTORY_ID) is not null
ORDER BY month ASC, CAR_ID DESC;
```

SELECT DISTINCT a.CAR_ID
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY a
JOIN (SELECT * FROM CAR_RENTAL_COMPANY_CAR b WHERE b.CAR_TYPE = '세단') c ON a.CAR_ID = c.CAR_ID
WHERE DATE_FORMAT(a.START_DATE, '%m') = 10
ORDER BY a.CAR_ID DESC;

JOIN 뒤에 서브쿼리를 사용하는 경우에도 테이블로 지칭되어
table alias를 사용해줘야 한다.

### 자동차 대여 기록에서 대여중 / 대여가능 여부 구분하기
```sql
-- 2022-10-16에 대여중인
-- 즉, 2022년 10월 16일 전이 START_DATE이면서
-- 2022년 10월 16일 이후 END_DATE인

SELECT CAR_ID, 
CASE
WHEN START_DATE <= '2022-10-16' AND END_DATE >= '2022-10-16' THEN '대여중'
ELSE '대여 가능'
END AS AVAILABILITY
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
ORDER BY CAR_ID DESC;
```

라고 처음에 생각했었는데, 생각해보니 대여중인 게 하나라도 있는 경우 '대여중'이고, 그렇지 않은 경우 '대여 가능'이다.

```sql
WITH RENTAL_STATUS AS (
    SELECT 
        CAR_ID, 
        CASE 
            WHEN '2022-10-16' BETWEEN START_DATE AND END_DATE THEN '대여중'
            ELSE '대여 가능'
        END AS AVAILABILITY
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
)

SELECT 
    CAR_ID,
    CASE 
        WHEN SUM(CASE WHEN AVAILABILITY = '대여중' THEN 1 ELSE 0 END) > 0 THEN '대여중'
        ELSE '대여 가능'
    END AS FINAL_AVAILABILITY
FROM RENTAL_STATUS
GROUP BY CAR_ID
ORDER BY CAR_ID DESC;
```